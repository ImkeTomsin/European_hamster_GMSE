print(plot_crops)
# extinction probability
reps <- max(data_crops$rep)
# Initialize a counter for extinction events
extinction_count <- 0
# Loop through each repetition
for (i in 1:reps) {
# Subset data for the current repetition
rep_data <- subset(data_crops, rep == i)
# Check if the population size ever reaches zero
if (any(rep_data$Pop_size == 0)) {
extinction_count <- extinction_count + 1
}
}
# Calculate the probability of extinction
probability_extinction <- extinction_count / reps
# Print the result
print(paste("Probability of extinction:", probability_extinction))
# Combine the mean population sizes from all analyses into a single data frame
combined_mean_pop2 <- rbind(mean_pop1, mean_pop2, mean_pop3, mean_pop4)
combined_mean_pop2$Analysis <- rep(c("Scenario 1", "Scenario 2","Scenario 3","Scenario 4"), each = nrow(mean_pop1))
# Plot the combined mean population sizes
custom_colors <- c( "#D0832E", "#EBD657", "#2FABAB", "#92C37F")  # Adjust colors as needed
ggplot(combined_mean_pop2, aes(x = Pop_size+1, y = Pop_size, color = Analysis)) +
geom_line(linewidth=0.7) +
theme_minimal()+
labs(x = "Time", y = "Mean Population Size")+
scale_x_continuous(expand = c(0, 0), limits = c(0, 60))+  # Ensure x-axis starts at 0 and stops at 60
scale_y_continuous(expand = c(0, 0), limits = c(0, NA))+ # Same for y-axis
scale_color_manual(values = custom_colors) +  # Apply custom colors
theme(
axis.title = element_text(size = 14),  # Increase size of axis titles
axis.text = element_text(size = 12),   # Increase size of axis labels
legend.title = element_text(size = 14), # Increase size of legend titles
legend.text = element_text(size = 12)  # Increase size of legend text
)
final_populations <- sim_1 %>% filter(Time == 60) %>% pull(Pop_size)
# Plot the histogram
ggplot(data.frame(FinalPopulation = final_populations), aes(x = FinalPopulation)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
labs(title = "Histogram of Final Population Sizes",
x = "Final Population Size",
y = "Frequency") +
theme_minimal()
final_populations <- sim_3 %>% filter(Time == 60) %>% pull(Pop_size)
# Plot the histogram
ggplot(data.frame(FinalPopulation = final_populations), aes(x = FinalPopulation)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
labs(title = "Histogram of Final Population Sizes",
x = "Final Population Size",
y = "Frequency") +
theme_minimal()
final_populations <- sim_4 %>% filter(Time == 60) %>% pull(Pop_size)
# Plot the histogram
ggplot(data.frame(FinalPopulation = final_populations), aes(x = FinalPopulation)) +
geom_histogram(binwidth = 1, fill = "blue", color = "black") +
labs(title = "Histogram of Final Population Sizes",
x = "Final Population Size",
y = "Frequency") +
theme_minimal()
# function to calculate yearly growth rate (per year!)
calculate_yearly_growth_rate <- function(data, iteration) {
yearly_rates <- numeric(0)
for (year in 1:5) {
start_time <- (year - 1) * 12 + 1
end_time <- start_time + 11
start_pop <- data %>% filter(rep == iteration & Time == start_time) %>% pull(Pop_size)
end_pop <- data %>% filter(rep == iteration & Time == end_time) %>% pull(Pop_size)
if (length(start_pop) > 0 & length(end_pop) > 0 & start_pop != 0) {
yearly_rate <- (end_pop - start_pop) / start_pop
yearly_rates <- c(yearly_rates, yearly_rate)
}
}
return(yearly_rates)
}
# Apply the function to each iteration
iterations <- unique(data$rep)
# function to calculate yearly growth rate (per year!)
calculate_yearly_growth_rate <- function(sim_3, iteration) {
yearly_rates <- numeric(0)
for (year in 1:5) {
start_time <- (year - 1) * 12 + 1
end_time <- start_time + 11
start_pop <- data %>% filter(rep == iteration & Time == start_time) %>% pull(Pop_size)
end_pop <- data %>% filter(rep == iteration & Time == end_time) %>% pull(Pop_size)
if (length(start_pop) > 0 & length(end_pop) > 0 & start_pop != 0) {
yearly_rate <- (end_pop - start_pop) / start_pop
yearly_rates <- c(yearly_rates, yearly_rate)
}
}
return(yearly_rates)
}
# Apply the function to each iteration
iterations <- unique(sim_3$rep)
all_growth_rates <- lapply(iterations, function(iter) calculate_yearly_growth_rate(sim_3, iter))
# Calculate the average yearly growth rate for each iteration
average_yearly_growth_rates <- sapply(all_growth_rates, mean, na.rm = TRUE)
# Calculate the overall average yearly growth rate
overall_average_growth_rate <- mean(average_yearly_growth_rates, na.rm = TRUE)
calculate_average_yearly_growth_rate <- function(sim_3, iteration) {
start_pop <- sim_3 %>% filter(rep == iteration & Time == 1) %>% pull(Pop_size)
end_pop <- sim_3 %>% filter(rep == iteration & Time == 60) %>% pull(Pop_size)
if (length(start_pop) > 0 & length(end_pop) > 0 & start_pop != 0) {
total_growth_rate <- (end_pop - start_pop) / start_pop
average_yearly_growth_rate <- total_growth_rate / 5
return(average_yearly_growth_rate)
} else {
return(NA)
}
}
# Apply the function to each iteration
iterations <- unique(data$rep)
# Apply the function to each iteration
iterations <- unique(sim_3$rep)
average_yearly_growth_rates <- sapply(iterations, function(iter) calculate_average_yearly_growth_rate(sim_3, iter))
# Calculate the overall average yearly growth rate
overall_average_growth_rate <- mean(average_yearly_growth_rates, na.rm = TRUE)
# Print the overall average yearly growth rate
print(overall_average_growth_rate)
(15-1.55)/15
(1.55-15)/15
((1.55-15)/15)/5
# Print the overall average yearly growth rate
print(overall_average_growth_rate)
((1.55-15)/15)/5
combined_pop1 <- merge(mean_pop1, sd_pop1, by = "Time", suffixes = c("_mean", "_sd"))
# Repeat for other simulations
combined_pop2 <- merge(mean_pop2, sd_pop2, by = "Time", suffixes = c("_mean", "_sd"))
combined_pop3 <- merge(mean_pop3, sd_pop3, by = "Time", suffixes = c("_mean", "_sd"))
combined_pop4 <- merge(mean_pop4, sd_pop4, by = "Time", suffixes = c("_mean", "_sd"))
# Calculate CV for sim_1
combined_pop1$CV <- (combined_pop1$Pop_size_sd / combined_pop1$Pop_size_mean) * 100
# Repeat for other simulations
combined_pop2$CV <- (combined_pop2$Pop_size_sd / combined_pop2$Pop_size_mean) * 100
combined_pop3$CV <- (combined_pop3$Pop_size_sd / combined_pop3$Pop_size_mean) * 100
combined_pop4$CV <- (combined_pop4$Pop_size_sd / combined_pop4$Pop_size_mean) * 100
# Combine the mean population sizes from all analyses into a single data frame
combined_mean_pop <- rbind(mean_pop5, mean_pop6)
combined_mean_pop$Analysis <- rep(c("15 100", "250 100"), each = nrow(mean_pop1))
# Plot the combined mean population sizes
ggplot(combined_mean_pop, aes(x = Time, y = Pop_size, color = Analysis)) +
geom_line() +
theme_minimal()+
labs(x = "Time", y = "Mean Population Size", title = "Mean Population Size Over Time")+
scale_x_continuous(expand = c(0, 0), limits = c(0, 60))+  # Ensure x-axis starts at 0 and stops at 60
scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) # Same for y-axis
# Combine the mean population sizes from all analyses into a single data frame
combined_mean_pop <- rbind(mean_pop5, mean_pop6)
mean_pop1 <- aggregate(Pop_size ~ Time, sim_1, mean)
mean_pop2 <- aggregate(Pop_size ~ Time, sim_2, mean)
mean_pop3 <- aggregate(Pop_size ~ Time, sim_3, mean)
mean_pop4 <- aggregate(Pop_size ~ Time, sim_4, mean)
mean_pop5 <- aggregate(Pop_size ~ Time, sim_5, mean)
mean_pop6 <- aggregate(Pop_size ~ Time, sim_6, mean)
# Calculate the standard deviation
sd_pop1 <- aggregate(Pop_size ~ Time, sim_1, sd)
sd_pop2 <- aggregate(Pop_size ~ Time, sim_2, sd)
sd_pop3 <- aggregate(Pop_size ~ Time, sim_3, sd)
sd_pop4 <- aggregate(Pop_size ~ Time, sim_4, sd)
sd_pop5 <- aggregate(Pop_size ~ Time, sim_5, sd)
sd_pop6 <- aggregate(Pop_size ~ Time, sim_6, sd)
# Combine the mean population sizes from all analyses into a single data frame
combined_mean_pop <- rbind(mean_pop5, mean_pop6)
combined_mean_pop$Analysis <- rep(c("15 100", "250 100"), each = nrow(mean_pop5))
# Plot the combined mean population sizes
ggplot(combined_mean_pop, aes(x = Time, y = Pop_size, color = Analysis)) +
geom_line() +
theme_minimal()+
labs(x = "Time", y = "Mean Population Size", title = "Mean Population Size Over Time")+
scale_x_continuous(expand = c(0, 0), limits = c(0, 60))+  # Ensure x-axis starts at 0 and stops at 60
scale_y_continuous(expand = c(0, 0), limits = c(0, NA)) # Same for y-axis
View(mean_pop3)
View(mean_pop6)
View(mean_pop5)
View(sd_pop6)
View(sd_pop5)
TMAX <- 60; # Maximum number of months in the simulation
JAN  <- seq(from = 1,  to = TMAX, by = 12); # Time steps in JAN, FEB, MAR, etc.
FEB  <- seq(from = 2,  to = TMAX, by = 12);
MAR  <- seq(from = 3,  to = TMAX, by = 12);
APR  <- seq(from = 4,  to = TMAX, by = 12);
MAY  <- seq(from = 5,  to = TMAX, by = 12);
JUN  <- seq(from = 6,  to = TMAX, by = 12);
JUL  <- seq(from = 7,  to = TMAX, by = 12);
AUG  <- seq(from = 8,  to = TMAX, by = 12);
SEP  <- seq(from = 9,  to = TMAX, by = 12);
OCT  <- seq(from = 10, to = TMAX, by = 12);
NOV  <- seq(from = 11, to = TMAX, by = 12);
DEC  <- seq(from = 12, to = TMAX, by = 12)
# This way, we are able to use each time step in the GMSE loop to identify the month
cell_K <- function(res, DIM_1 = 447, DIM_2 = 447){
for(i in 1:DIM_1){
for(j in 1:DIM_2){
sum_ij <- sum(res[, 5] == i & res[, 6] == j)
if(sum_ij > 1){
on_ij             <- which(res[, 5] == i & res[, 6] == j);
loser_ij          <- sample(x = on_ij, size = sum_ij - 1);
res[loser_ij, 7]  <- 0; # Stop in tracks
res[loser_ij, 9]  <- 1; # Definite death
res[loser_ij, 10] <- 0; # No birth
res[loser_ij, 11] <- 0; # No birth
}
}
}
return(res);
}
#Now, if two hamsters occupy the same cell, one of them will die.
#This should be run after movement has happened, so that offspring are not removed before
#reproductively active/old enough to leave the mother
#This function is quite slow -- probably want to speed it up somehow
library(GMSE)
DIM_1 <- 447; # Land dimension 1
DIM_2 <- 447; # Land dimension 2
iterations <- 100 #number of iterations
results <- list() #list to store results from each repetition
for (rep in 1:iterations) {
tryCatch({
# Initialise the first output
sim_old   <- gmse_apply(stakeholders    = 1, # not important here as landscape is all the same and no actions are being taken
res_movement    = 100,
remove_pr       = 1 - 0.976083968,
lambda          = 0,
res_death_type  = 1,
observe_type    = 2, # but only once a year
res_move_obs    = FALSE,
max_ages        = 24,
RESOURCE_ini    = 250, # N
culling         = FALSE,
land_ownership  = TRUE,
age_repr        = 4,
land_dim_1      = DIM_1,
land_dim_2      = DIM_2,
manage_target   = 2500,
res_move_type   = 0,
get_res         = 'Full');
old_obs  <- sim_old[["observation_array"]];
# Initialise the results matrix for the current iteration; Currently, 2 variables are recorded as output
# Double-brackets: technically a bit more secure. It works if you edit columns of the resource_array directly.
sim_sum_1 <- matrix(data = NA, nrow = TMAX, ncol = 2);
colnames(sim_sum_1) <- c("Time", "Pop_size");
moving_month <- 0;
for(time_step in 1:TMAX){
sim_new                 <- gmse_apply(old_list = sim_old, get_res = 'Full',
res_move_type = moving_month);
sim_sum_1[time_step, 1] <- time_step;
sim_sum_1[time_step, 2] <- sim_new$basic_output$resource_results[1];
next_time               <- time_step + 1; # What happens next time step?
if(next_time %in% JAN){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.976083968; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% FEB){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.94824969; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% MAR){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.9023544; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% APR){
moving_month                      <- 1; # A moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.811569975; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% MAY){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.805694059; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
temp_res                          <- sim_new[["resource_array"]];
sim_new[["resource_array"]]       <- cell_K(res   = temp_res, DIM_1 = DIM_1,
DIM_2 = DIM_2);
}
if(next_time %in% JUN){
moving_month                      <- 1; # A moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.794513672; # Death probability
sim_new[["resource_array"]][, 10] <- 1.46;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% JUL){
moving_month                      <- 1; # A moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.767700722; # Death probability
sim_new[["resource_array"]][, 10] <- 1.46;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
temp_res                          <- sim_new[["resource_array"]];
sim_new[["resource_array"]]       <- cell_K(res   = temp_res, DIM_1 = DIM_1,
DIM_2 = DIM_2);
}
if(next_time %in% AUG){
moving_month                      <- 1; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.842305069; # Death probability
sim_new[["resource_array"]][, 10] <- 1.46;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
temp_res                          <- sim_new[["resource_array"]];
sim_new[["resource_array"]]       <- cell_K(res   = temp_res, DIM_1 = DIM_1,
DIM_2 = DIM_2);
}
if(next_time %in% SEP){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.877005333; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
temp_res                          <- sim_new[["resource_array"]];
sim_new[["resource_array"]]       <- cell_K(res   = temp_res, DIM_1 = DIM_1,
DIM_2 = DIM_2);
}
if(next_time %in% OCT){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.891729601; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% NOV){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.939895976; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% DEC){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.956833861; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
sim_old <- sim_new; # BD: This should always go at the end
#print(sim_sum_1[time_step,]); #Activate to see the simulation progress
}
}, error = function(e) { #tryCatch: if error occurs because N = 0
cat("Error occurred in iteration", rep, ":", conditionMessage(e), "\n")
}) #end of tryCatch
sim_sum_1 <- cbind(rep, sim_sum_1); # Add iteration number as a column
print(sim_sum_1);
results[[rep]] <- sim_sum_1
}
combined_results <- do.call(rbind, results)
combined_results[is.na(combined_results)] <- 0
#now timestep is also recorded as a 0 from the moment extinction occurred, we want time step to be recorded correctly
combined_results <- as.data.frame(combined_results)
# Loop through each repetition
for (rep_id in unique(combined_results$rep)) {
# Subset data for the current repetition
rep_data <- combined_results[combined_results$rep == rep_id, ]
# Loop through each row in the current repetition's data
for (i in 2:nrow(rep_data)) {
# If the current time step is 0, replace it with the previous time step + 1
if (rep_data$Time[i] == 0) {
rep_data$Time[i] <- rep_data$Time[i - 1] + 1
}
}
# Replace the data for the current repetition in the original data frame
combined_results[combined_results$rep == rep_id, ] <- rep_data
}
file_path <- "C:/Users/imket/Documents/GitHub/European_hamster_GMSE/Output/Simulation7_100it_250startN.csv" #Give the simulation an appropriate name
write.csv(combined_results, file = file_path, row.names = FALSE)
library(GMSE)
DIM_1 <- 447; # Land dimension 1
DIM_2 <- 447; # Land dimension 2
iterations <- 100 #number of iterations
results <- list() #list to store results from each repetition
for (rep in 1:iterations) {
tryCatch({
# Initialise the first output
sim_old   <- gmse_apply(stakeholders    = 1, # not important here as landscape is all the same and no actions are being taken
res_movement    = 100,
remove_pr       = 1 - 0.976083968,
lambda          = 0,
res_death_type  = 1,
observe_type    = 2, # but only once a year
res_move_obs    = FALSE,
max_ages        = 24,
RESOURCE_ini    = 250, # N
culling         = FALSE,
land_ownership  = TRUE,
age_repr        = 4,
land_dim_1      = DIM_1,
land_dim_2      = DIM_2,
manage_target   = 2500,
res_move_type   = 0,
get_res         = 'Full');
old_obs  <- sim_old[["observation_array"]];
# Initialise the results matrix for the current iteration; Currently, 2 variables are recorded as output
# Double-brackets: technically a bit more secure. It works if you edit columns of the resource_array directly.
sim_sum_1 <- matrix(data = NA, nrow = TMAX, ncol = 2);
colnames(sim_sum_1) <- c("Time", "Pop_size");
moving_month <- 0;
for(time_step in 1:TMAX){
sim_new                 <- gmse_apply(old_list = sim_old, get_res = 'Full',
res_move_type = moving_month);
sim_sum_1[time_step, 1] <- time_step;
sim_sum_1[time_step, 2] <- sim_new$basic_output$resource_results[1];
next_time               <- time_step + 1; # What happens next time step?
if(next_time %in% JAN){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.976083968; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% FEB){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.94824969; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% MAR){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.9023544; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% APR){
moving_month                      <- 1; # A moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.811569975; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% MAY){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.805694059; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
temp_res                          <- sim_new[["resource_array"]];
sim_new[["resource_array"]]       <- cell_K(res   = temp_res, DIM_1 = DIM_1,
DIM_2 = DIM_2);
}
if(next_time %in% JUN){
moving_month                      <- 1; # A moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.794513672; # Death probability
sim_new[["resource_array"]][, 10] <- 3;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% JUL){
moving_month                      <- 1; # A moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.767700722; # Death probability
sim_new[["resource_array"]][, 10] <- 3;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
temp_res                          <- sim_new[["resource_array"]];
sim_new[["resource_array"]]       <- cell_K(res   = temp_res, DIM_1 = DIM_1,
DIM_2 = DIM_2);
}
if(next_time %in% AUG){
moving_month                      <- 1; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.842305069; # Death probability
sim_new[["resource_array"]][, 10] <- 3;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
temp_res                          <- sim_new[["resource_array"]];
sim_new[["resource_array"]]       <- cell_K(res   = temp_res, DIM_1 = DIM_1,
DIM_2 = DIM_2);
}
if(next_time %in% SEP){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.877005333; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
temp_res                          <- sim_new[["resource_array"]];
sim_new[["resource_array"]]       <- cell_K(res   = temp_res, DIM_1 = DIM_1,
DIM_2 = DIM_2);
}
if(next_time %in% OCT){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.891729601; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% NOV){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.939895976; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
if(next_time %in% DEC){
moving_month                      <- 0; # Not a moving month
sim_new[["resource_array"]][, 9]  <- 1 - 0.956833861; # Death probability
sim_new[["resource_array"]][, 10] <- 0;         # Birth probability
sim_new[["observation_array"]]    <- old_obs;   # Use old observations
}
sim_old <- sim_new; # BD: This should always go at the end
#print(sim_sum_1[time_step,]); #Activate to see the simulation progress
}
}, error = function(e) { #tryCatch: if error occurs because N = 0
cat("Error occurred in iteration", rep, ":", conditionMessage(e), "\n")
}) #end of tryCatch
sim_sum_1 <- cbind(rep, sim_sum_1); # Add iteration number as a column
print(sim_sum_1);
results[[rep]] <- sim_sum_1
}
combined_results <- do.call(rbind, results)
combined_results[is.na(combined_results)] <- 0
#now timestep is also recorded as a 0 from the moment extinction occurred, we want time step to be recorded correctly
combined_results <- as.data.frame(combined_results)
# Loop through each repetition
for (rep_id in unique(combined_results$rep)) {
# Subset data for the current repetition
rep_data <- combined_results[combined_results$rep == rep_id, ]
# Loop through each row in the current repetition's data
for (i in 2:nrow(rep_data)) {
# If the current time step is 0, replace it with the previous time step + 1
if (rep_data$Time[i] == 0) {
rep_data$Time[i] <- rep_data$Time[i - 1] + 1
}
}
# Replace the data for the current repetition in the original data frame
combined_results[combined_results$rep == rep_id, ] <- rep_data
}
file_path <- "C:/Users/imket/Documents/GitHub/European_hamster_GMSE/Output/Simulation8_100it_250startN.csv" #Give the simulation an appropriate name
write.csv(combined_results, file = file_path, row.names = FALSE)
